---
title: "InnoDB Full text Search hacking with Shiny/R"
author: "Emanuel Calvo"
company: "Pythian"
date: "December 22, 2015"
output: html_document
runtime: shiny
---

```{r init, message = FALSE, echo=FALSE}
#options(width = 9999)
#knitr::opts_chunk$set(width=9999)

library(knitr)
library(shiny)
require(RMySQL)
library(ggplot2)

#Comment if you want to avoid reload all the data
#source('~/fts_article/load.R')

# Yeah, only for development environements
all_cons <- dbListConnections(MySQL())
for(con in all_cons) dbDisconnect(con)


# You do not want clear passwords, but is a sandbox.
con <- dbConnect(MySQL(), 
                 user="msandbox", password="msandbox", port=14901 
                 ,dbname="test", socket="/tmp/mysql_sandbox14901.sock", 
                 host="127.0.0.1")


```

This R Markdown document is made interactive using Shiny. Unlike the more traditional workflow of creating static reports, you can now create documents that allow your readers to change the assumptions underlying your analysis and see the results immediately.  To learn more, see [Interactive Documents](http://rmarkdown.rstudio.com/authoring_shiny.html).


> You only need to have a MySQL sandbox with the 5.7 version.

## Moto of the article

A couple of days ago one of our customers came up with a question regarding FTS over InnoDB engine. Althuogh the question
is not entirely related with most of the content written here, I came up with the conclusion that FTS sometimes is a misunderstood feature.

The point of this article will be clarify when each algorithm fits in each situation.  

Both official documentation and articles are propagated over internet, however sometimes most of them lacks to answer the
main questions and test cases. In order to follow a reproducible article, I used public available data sources (www.gutenberg.org).

In order to show the effects off the field sizes on the ranking algorithms, you will see two main tables (bookContent and 
bookContentByLine) which contains the books parsed by paragraph and by line respectively. You'll see the noise generated
by the `QUERY EXPANSION` algorithm when phrases are too large, and that's why you see both tables.

The current article has been developed using Shiny/R in order to allow you to see the effects of the algorithms.  

Here is an example of how ranks differ among algorithms and field sizes using the word 'country':

```
set global innodb_ft_aux_table = 'test/bookContentByLine';
 
SELECT  content, group_concat(it.POSITION) as positions, 
        round(MATCH(content) AGAINST ("country" IN NATURAL LANGUAGE MODE WITH QUERY EXPANSION)) as QERank, 
        round(MATCH(content) AGAINST ("country*" IN BOOLEAN MODE)) as BooleanRank, 
        length(content) as len 
      FROM bookContentByLine bl join information_schema.INNODB_FT_INDEX_TABLE it 
          ON (bl.FTS_DOC_ID = it.DOC_ID)  
      WHERE  MATCH(content) AGAINST ("country" IN NATURAL LANGUAGE MODE WITH QUERY EXPANSION) 
          AND lower(it.WORD) like '%country%' group by FTS_DOC_ID ORDER BY 3 DESC LIMIT 10 ;

+---------------------------------------------------------------------------+-----------+--------+-------------+------+
| content                                                                   | positions | QERank | BooleanRank | len  |
+---------------------------------------------------------------------------+-----------+--------+-------------+------+
| "country may be ennobled, and under its auspices may be verified that"    | 1         |     54 |           4 |   70 |
| "country, under a most excellent president, wherein all cities had their" | 1         |     53 |           4 |   73 |
| "Again, the prince who holds a country differing in the above respects"   | 31        |     51 |           4 |   71 |
| "country districts. As Lucca had five gates, he divided his own country"  | 1,63      |     51 |           8 |   72 |
| "inflicting immense damage upon the country. Whereupon the Florentines"   | 36        |     50 |           4 |   71 |
| "The cities of Germany are absolutely free, they own but little country"  | 64        |     49 |           4 |   72 |
| "citizens of Fermo, to whom the slavery of their country was dearer than" | 49        |     48 |           4 |   73 |
| "is useful in two ways. Firstly, he learns to know his country, and"      | 55        |     46 |           4 |   68 |
| "agree that he should retain any lordship over the country. Because the"  | 51        |     45 |           4 |   72 |
| "his own parts of the country, according to the authority he had assumed" | 22        |     43 |           4 |   73 |
+---------------------------------------------------------------------------+-----------+--------+-------------+------+


```

The noise generated by the query expansion is expected and described in the official documentation [here.](https://dev.mysql.com/doc/refman/5.7/en/fulltext-query-expansion.html)

The interesting case is the following row, which has 2 exact occurrences and it is not the highest rank using query
extension. Remember, this is expected.

```
| "country districts. As Lucca had five gates, he divided his own country"  | 1,63      |     51 |           8 |   72 |
```

This is even worser when using large sentences. In the example bellow you will see the same query, against the table 
storing by paragraph. The boolean rank shows some of the entries way above others, however the query extension
locates at the top records that not necessarily has a lot of exact matches.

```

(test) > set global innodb_ft_aux_table = 'test/bookContent';
Query OK, 0 rows affected (0,00 sec)

(test) > SELECT FTS_DOC_ID, 
                group_concat(it.POSITION) as positions, 
                round(MATCH(content) AGAINST ("country" IN NATURAL LANGUAGE MODE WITH QUERY EXPANSION)) as QERank, 
                round(MATCH(content) AGAINST ("country*" IN BOOLEAN MODE)) as BooleanRank, 
                length(content) as len 
          FROM bookContent bl join information_schema.INNODB_FT_INDEX_TABLE it ON (bl.FTS_DOC_ID = it.DOC_ID)  
          WHERE  MATCH(content) AGAINST ("country" IN NATURAL LANGUAGE MODE WITH QUERY EXPANSION) 
              AND lower(it.WORD) like '%country%' group by FTS_DOC_ID ORDER BY QERank DESC LIMIT 10 ;
+------------+------------------+--------+-------------+------+
| FTS_DOC_ID | positions        | QERank | BooleanRank | len  |
+------------+------------------+--------+-------------+------+
|        757 | 6858             |   2804 |           1 | 8101 | <<< This one on the top does only 1 exact match.
|        735 | 2842             |    925 |           1 | 3133 |
|        157 | 747              |    698 |           1 | 2385 |
|        733 | 265,1342,816,750 |    569 |           2 | 1765 |
|        739 | 1171             |    540 |           1 | 1659 |
|        249 | 197,739          |    435 |           1 | 1368 |
|        279 | 664              |    428 |           1 | 1365 |
|        411 | 468,410          |    396 |           2 | 1170 |
|        155 | 31,495,158,525   |    363 |           5 | 1378 |  <<< This doc contains 5 exact matches!
|        327 | 60               |    362 |           1 | 1372 |
+------------+------------------+--------+-------------+------+
10 rows in set (4,09 sec)
```


This kind of searches is useful if you want to find entries with words that appear frequently within your search.


```{r, message=FALSE, echo=FALSE}
sql <- "SELECT avg(length(content)) as len from bookContent"
rs <- dbGetQuery(con,sql)
```

Following stats are from the bookContent table (which has an average length of `r rs$len` characters ).

```
(test) > select * 
          from information_schema.INNODB_FT_INDEX_TABLE 
          WHERE DOC_ID = 733 AND lower(WORD) like '%country%';
+------------------+--------------+-------------+-----------+--------+----------+
| WORD             | FIRST_DOC_ID | LAST_DOC_ID | DOC_COUNT | DOC_ID | POSITION |
+------------------+--------------+-------------+-----------+--------+----------+
| country          |          149 |         787 |        28 |    733 |      265 |
| country          |          149 |         787 |        28 |    733 |     1342 |
| countrydistricts |          733 |         733 |         1 |    733 |      816 |
| thecountry       |          249 |         733 |         2 |    733 |      750 |
+------------------+--------------+-------------+-----------+--------+----------+
4 rows in set (0,08 sec)

(test) > select * 
          from information_schema.INNODB_FT_INDEX_TABLE 
          WHERE DOC_ID = 155 AND lower(WORD) like '%country%';
+---------+--------------+-------------+-----------+--------+----------+
| WORD    | FIRST_DOC_ID | LAST_DOC_ID | DOC_COUNT | DOC_ID | POSITION |
+---------+--------------+-------------+-----------+--------+----------+
| country |          149 |         787 |        28 |    155 |       31 |
| country |          149 |         787 |        28 |    155 |      495 |
| country |          149 |         787 |        28 |    155 |      158 |
| country |          149 |         787 |        28 |    155 |      525 |
+---------+--------------+-------------+-----------+--------+----------+
4 rows in set (0,09 sec)

```

> In the example shown before the is no intention to compare ranks score as they are based in different algorithms. 
> The idea there is to show that QUERY EXPANSION can have non desire results in some cases due to its mechanism.



## Stats 



```{r, echo=FALSE}

sql <- "SELECT bp.bookid, round(avg(length(bp.content))) as avgLength, round(STD(length(bp.content))) as stdLength, count(*) as numEntries 
            FROM bookContent bp  
            GROUP BY bookid;"
rs <- dbGetQuery(con, sql)
return(rs)

bookContentStats <- rs


sql <- "SELECT bl.bookid, round(avg(length(bl.content))) as avgLength, round(STD(length(bl.content))) as stdLength, count(*) as numEntries 
            FROM  bookContentByLine bl 
            GROUP BY bookid;"
rs <- dbGetQuery(con, sql)
return(rs)

bookContentByLineStats <- rs

```



## Playing with searches

The following form will allow you to search across the stats over the tables of the filtering provided dynamically. 

The aggregations shown on the results are over the results using the selected algorithm. 

You can start trying `+country +(>house <president) -home` in boolean mode. For more information about operator in Innodb's FTS,
you can read [this.](https://dev.mysql.com/doc/refman/5.7/en/fulltext-boolean.html) Using boolean formulas in NATURAL LANGUAGE MODE,
does not have the desired effect, however you'll be able to see how it affects the ranking compared with the boolean search. 

NOTE: distance operator not yet supported.


```{r, echo=FALSE}
        ui <- shinyUI(fluidPage(
                mainPanel(  
                          selectInput("ftsMode", label = "Algorithm:",
                                      choices = c("WITH QUERY EXPANSION", "IN BOOLEAN MODE", "IN NATURAL LANGUAGE MODE"), selected = "WITH QUERY EXPANSION"),
                          textInput("filtering", "FTS Filter:", "default"),
                          submitButton("Stats!"),
                          # uiOutput('tableResults'),
                          uiOutput('table'),
                          uiOutput('tableResults')
                          )
                       ))

        server <- function(input, output, session) {
                
                DataResults = reactive({
                   f<-function(x) {as.character(input$filtering)}
                  sql <- paste("SELECT * FROM bookContentByLine WHERE MATCH(content) AGAINST(\"" ,f(x)," \" ",input$ftsMode,") LIMIT 10", sep = "")
                  
                  rs <- dbGetQuery(con, sql)
                  return(rs)
                  
                })
                
                output$tableResults <- renderTable({DataResults()})

                Data = reactive({
                  f<-function(x) {as.character(input$filtering)}
                  
                      sql <- paste("SELECT sourceTable, 
                                      max(scoreBoolean) as maxBoolean,
                                      max(scoreQE) as maxQE,
                                      -- max(scoreNL) as maxNL,
                                      avg(scoreBoolean) as avgBoolean, 
                                      avg(scoreQE) as avgQE,
                                      -- avg(scoreNL) as avgNL,
                                      avg(lengthContent) avgFieldLength,
                                      -- avg(scoreQE) / count(sourceTable) as weight,
                                      count(sourceTable) as countOccurrences
                              FROM
                              (
                              SELECT \"byParagraph\" as sourceTable, 
                                    FTS_DOC_ID, 
                                    match(BC.content) against (\"" ,f(x) ," \" IN BOOLEAN MODE) as scoreBoolean,
                                    match(BC.content) 
                                        against (\""  ,f(x), "\" IN NATURAL LANGUAGE MODE WITH QUERY EXPANSION) scoreQE,
                                    match(BC.content) 
                                        against (\""  ,f(x), "\" IN NATURAL LANGUAGE MODE) scoreNL,
                                     length(content) as lengthContent
                              FROM    bookContent BC
                              WHERE
                                match(BC.content) against (\"" ,f(x)," \" ",input$ftsMode,")
                              UNION
                              SELECT \"byLine\" as sourceTable, 
                                      FTS_DOC_ID, match(BL.content) against (\"",f(x)," \" IN BOOLEAN MODE) as scoreBoolean,
                                     match(BL.content) 
                                      against (\"" ,f(x)," \" IN NATURAL LANGUAGE MODE WITH QUERY EXPANSION) scoreQE,
                                    match(BL.content) 
                                        against (\""  ,f(x), "\" IN NATURAL LANGUAGE MODE) scoreNL,
                                     length(content) as lengthContent
                              FROM
                                      bookContentByLine BL
                              WHERE
                                match(BL.content) against (\"", f(x) ,"\" ",input$ftsMode,")
                              ) unionTable
                              GROUP BY sourceTable
                              ;" , sep = "")

                      rs <- dbGetQuery(con, sql)
                      return(rs)
                      
                })
                        
                output$table <- renderTable({Data()})
                      
        }

shinyApp(ui = ui, server = server)

```


Now that you can see the general stats, we'll see how much noise has been added with the query extension algorithm.
To do that,  we'll gather all the occurrences using the query extension option and extract only the ones that match 
with the occurrence.


## Recommendations 

- Use QUERY EXPANSION only if you are interested to search relations over exact matches. Remember that the field
  size is crucial when using this.
- FTS is not the best fit for exact string matches. You won't use FTS for searching emails or strings as words using
  single fields. 
- If you are using BOOLEAN MODE, you can use the rank score to filter rows. MySQL is clever enough to optimize the 
  FTS functions to avoid double executions. You can do this using somehting like:
  `match(content,title) against ("first (<second >third)") > 1 `
  Generally, scores lower than 1 can be ignored when using boolean or natural mode searches. 
- `OPTIMIZE TABLE` does a rebuild of the table. To avoid this, set `innodb_optimize_fulltext_only=1` in order to do an incremental
  maintance on the table.
- Recall that NATURAL LANGUAGE MODE does not take the operands as the BOOLEAN MODE.
- If you want to have the results ordered by the last FTS expression in the WHERE clause, don't use `ORDER BY`, as MySQL
  forcely does an order internally. 
- Try to don't use more than one FTS expression in the where clause. Keep in mind that this affects the order in the results and
  it consumes a considerably amount of CPU.



---------------------- FROM HERE ONLY TRASH TO BE REMOVED -----------------------------


Template

```{r}
inputPanel(
  selectInput("n_breaks", label = "Number of bins:",
              choices = c(10, 20, 35, 50), selected = 20),
  
  sliderInput("bw_adjust", label = "Bandwidth adjustment:",
              min = 0.2, max = 2, value = 1, step = 0.2)
)

renderPlot({
  hist(faithful$eruptions, probability = TRUE, breaks = as.numeric(input$n_breaks),
       xlab = "Duration (minutes)", main = "Geyser eruption duration")
  
  dens <- density(faithful$eruptions, adjust = input$bw_adjust)
  lines(dens, col = "blue")
})
```

## Embedded Application

It's also possible to embed an entire Shiny application within an R Markdown document using the `shinyAppDir` function. This example embeds a Shiny application located in another directory:

```{r, echo=FALSE}
shinyAppDir(
  system.file("examples/06_tabsets", package="shiny"),
  options=list(
    width="100%", height=550
  )
)
```

Note the use of the `height` parameter to determine how much vertical space the embedded application should occupy.

You can also use the `shinyApp` function to define an application inline rather then in an external directory.

In all of R code chunks above the `echo = FALSE` attribute is used. This is to prevent the R code within the chunk from rendering in the document alongside the Shiny components.

### Fine tuning

[Fine tuning](https://dev.mysql.com/doc/refman/5.7/en/fulltext-fine-tuning.html)


### Maintenance

[innodb_optimize_fulltext_only](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_optimize_fulltext_only)

### Parsers internals

[Writting FTS parser plugins](https://dev.mysql.com/doc/refman/5.7/en/writing-full-text-plugins.html)



