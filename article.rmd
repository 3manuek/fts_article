---
title: "InnoDB Full text Search hacking with Shiny/R"
author: "Emanuel Calvo - Pythian"
date: "December 22, 2015"
output: html_document
runtime: shiny
---


```{r init, message = FALSE, echo=FALSE}
#options(width = 9999)
#knitr::opts_chunk$set(width=9999)
# opts_chunk$set(fig.width=9999) #, fig.height=6))

library(knitr)
library(shiny)
require(RMySQL)
library(ggplot2)

# Comment if you want to avoid reload all the data
# If you want to start from scratch, uncomment the following line.
# Otherwise, you can restore the dumps located in the dumps folder
#source('~/fts_article/load.R')

# Yeah, only for development environements
all_cons <- dbListConnections(MySQL())
for(con in all_cons) dbDisconnect(con)

# You do not want clear passwords, but is a sandbox.
#con <- dbConnect(MySQL(), 
#                 user="msandbox", password="msandbox", port=14901 
#                 ,dbname="test", socket="/tmp/mysql_sandbox14901.sock", 
#                 host="127.0.0.1")

con <- dbConnect(MySQL(), 
                 user="ftsinnodb", password="elfilete", port=3306 
                 ,dbname="ftsinnodb", #socket="/tmp/mysql_sandbox14901.sock",
                 host="db4free.net")

```

## Version

 **BETA - NOT FINAL** 

This R Markdown document is made interactive using Shiny. Unlike the more traditional workflow of creating static reports, you can now create documents that allow your readers to change the assumptions underlying your analysis and see the results immediately.  To learn more, see [Interactive Documents](http://rmarkdown.rstudio.com/authoring_shiny.html).

Repository available at [Github](https://github.com/3manuek/fts_article).

## Credits

Author: Emanuel Calvo
Company: Pythian

Thanks to Valerie Parham-Thompson @ Pythian and Daniel Prince @ Oracle.

Thanks db4free.net for the MySQL free online database!

## Requirements

> You only need to have a MySQL sandbox with the 5.7 version.

## Some initial thoughts

A couple of days ago one of our customers came up with a question regarding FTS over InnoDB engine. Althuogh the question
is not entirely related with most of the content written here, I came up with the conclusion that FTS sometimes is a misunderstood feature.

The point of this article will be clarify when each algorithm fits in each situation.  

Both official documentation and articles are propagated over internet, however sometimes most of them lacks to answer the
main questions and test cases. In order to follow a reproducible article, I used public available data sources (www.gutenberg.org).

In order to show the effects off the field sizes on the ranking algorithms, you will see two main tables (bookContent and 
bookContentByLine) which contains the books parsed by paragraph and by line respectively. You'll see the noise generated
by the `QUERY EXPANSION` algorithm when phrases are too large, and that's why you see both tables.

The current article has been developed using Shiny/R in order to allow you to see the effects of the algorithms.  

Here is an example of how ranks differ among algorithms and field sizes using the word 'country':

```
set global innodb_ft_aux_table = 'test/bookContentByLine';
 
SELECT  content, group_concat(it.POSITION) as positions, 
        round(MATCH(content) AGAINST ("country" IN NATURAL LANGUAGE MODE WITH QUERY EXPANSION)) as QERank, 
        round(MATCH(content) AGAINST ("country*" IN BOOLEAN MODE)) as BooleanRank, 
        length(content) as len 
      FROM bookContentByLine bl join information_schema.INNODB_FT_INDEX_TABLE it 
          ON (bl.FTS_DOC_ID = it.DOC_ID)  
      WHERE  MATCH(content) AGAINST ("country" IN NATURAL LANGUAGE MODE WITH QUERY EXPANSION) 
          AND lower(it.WORD) like '%country%' group by FTS_DOC_ID ORDER BY 3 DESC LIMIT 10 ;

+---------------------------------------------------------------------------+-----------+--------+-------------+------+
| content                                                                   | positions | QERank | BooleanRank | len  |
+---------------------------------------------------------------------------+-----------+--------+-------------+------+
| "country may be ennobled, and under its auspices may be verified that"    | 1         |     54 |           4 |   70 |
| "country, under a most excellent president, wherein all cities had their" | 1         |     53 |           4 |   73 |
| "Again, the prince who holds a country differing in the above respects"   | 31        |     51 |           4 |   71 |
| "country districts. As Lucca had five gates, he divided his own country"  | 1,63      |     51 |           8 |   72 |
| "inflicting immense damage upon the country. Whereupon the Florentines"   | 36        |     50 |           4 |   71 |
| "The cities of Germany are absolutely free, they own but little country"  | 64        |     49 |           4 |   72 |
| "citizens of Fermo, to whom the slavery of their country was dearer than" | 49        |     48 |           4 |   73 |
| "is useful in two ways. Firstly, he learns to know his country, and"      | 55        |     46 |           4 |   68 |
| "agree that he should retain any lordship over the country. Because the"  | 51        |     45 |           4 |   72 |
| "his own parts of the country, according to the authority he had assumed" | 22        |     43 |           4 |   73 |
+---------------------------------------------------------------------------+-----------+--------+-------------+------+


```

The noise generated by the query expansion is expected and described in the official documentation [here.](https://dev.mysql.com/doc/refman/5.7/en/fulltext-query-expansion.html)

The interesting case is the following row, which has 2 exact occurrences and it is not the highest rank using query
extension. Remember, this is expected.

```
| "country districts. As Lucca had five gates, he divided his own country"  | 1,63      |     51 |           8 |   72 |
```

This is even worser when using large sentences. In the example bellow you will see the same query, against the table 
storing by paragraph. The boolean rank shows some of the entries way above others, however the query extension
locates at the top records that not necessarily has a lot of exact matches.

```

(test) > set global innodb_ft_aux_table = 'test/bookContent';
Query OK, 0 rows affected (0,00 sec)

(test) > SELECT FTS_DOC_ID, 
                group_concat(it.POSITION) as positions, 
                round(MATCH(content) AGAINST ("country" IN NATURAL LANGUAGE MODE WITH QUERY EXPANSION)) as QERank, 
                round(MATCH(content) AGAINST ("country*" IN BOOLEAN MODE)) as BooleanRank, 
                length(content) as len 
          FROM bookContent bl join information_schema.INNODB_FT_INDEX_TABLE it ON (bl.FTS_DOC_ID = it.DOC_ID)  
          WHERE  MATCH(content) AGAINST ("country" IN NATURAL LANGUAGE MODE WITH QUERY EXPANSION) 
              AND lower(it.WORD) like '%country%' group by FTS_DOC_ID ORDER BY QERank DESC LIMIT 10 ;
+------------+------------------+--------+-------------+------+
| FTS_DOC_ID | positions        | QERank | BooleanRank | len  |
+------------+------------------+--------+-------------+------+
|        757 | 6858             |   2804 |           1 | 8101 | <<< This one on the top does only 1 exact match.
|        735 | 2842             |    925 |           1 | 3133 |
|        157 | 747              |    698 |           1 | 2385 |
|        733 | 265,1342,816,750 |    569 |           2 | 1765 |
|        739 | 1171             |    540 |           1 | 1659 |
|        249 | 197,739          |    435 |           1 | 1368 |
|        279 | 664              |    428 |           1 | 1365 |
|        411 | 468,410          |    396 |           2 | 1170 |
|        155 | 31,495,158,525   |    363 |           5 | 1378 |  <<< This doc contains 5 exact matches!
|        327 | 60               |    362 |           1 | 1372 |
+------------+------------------+--------+-------------+------+
10 rows in set (4,09 sec)
```


This kind of searches is useful if you want to find entries with words that appear frequently within your search.


```{r, message=FALSE, echo=FALSE}
sql <- "SELECT avg(length(content)) as len from bookContent"
rs <- dbGetQuery(con,sql)
```

Following stats are from the bookContent table (which has an average length of `r rs$len` characters ).

```
(test) > select * 
          from information_schema.INNODB_FT_INDEX_TABLE 
          WHERE DOC_ID = 733 AND lower(WORD) like '%country%';
+------------------+--------------+-------------+-----------+--------+----------+
| WORD             | FIRST_DOC_ID | LAST_DOC_ID | DOC_COUNT | DOC_ID | POSITION |
+------------------+--------------+-------------+-----------+--------+----------+
| country          |          149 |         787 |        28 |    733 |      265 |
| country          |          149 |         787 |        28 |    733 |     1342 |
| countrydistricts |          733 |         733 |         1 |    733 |      816 |
| thecountry       |          249 |         733 |         2 |    733 |      750 |
+------------------+--------------+-------------+-----------+--------+----------+
4 rows in set (0,08 sec)

(test) > select * 
          from information_schema.INNODB_FT_INDEX_TABLE 
          WHERE DOC_ID = 155 AND lower(WORD) like '%country%';
+---------+--------------+-------------+-----------+--------+----------+
| WORD    | FIRST_DOC_ID | LAST_DOC_ID | DOC_COUNT | DOC_ID | POSITION |
+---------+--------------+-------------+-----------+--------+----------+
| country |          149 |         787 |        28 |    155 |       31 |
| country |          149 |         787 |        28 |    155 |      495 |
| country |          149 |         787 |        28 |    155 |      158 |
| country |          149 |         787 |        28 |    155 |      525 |
+---------+--------------+-------------+-----------+--------+----------+
4 rows in set (0,09 sec)

```

> In the example shown before the is no intention to compare ranks score as they are based in different algorithms. 
> The idea there is to show that QUERY EXPANSION can have non desire results in some cases due to its mechanism.


## Considerations if you are planning to use Innodb's Full text search

- Use QUERY EXPANSION only if you are interested to search relations over exact matches. Remember that the field
  size is crucial when using this.
- FTS is not the best fit for exact string matches. You won't use FTS for searching emails or strings as words using
  single fields. 
- If you are using BOOLEAN MODE, you can use the rank score to filter rows. MySQL is clever enough to optimize the 
  FTS functions to avoid double executions. You can do this using somehting like:
  `match(content,title) against ("first (<second >third)") > 1 `
  Generally, scores lower than 1 can be ignored when using boolean or natural mode searches. 
- `OPTIMIZE TABLE` does a rebuild of the table. To avoid this, set `innodb_optimize_fulltext_only=1` in order to do an incremental
  maintance on the table.
- Recall that NATURAL LANGUAGE MODE does not take the operands as the BOOLEAN MODE.
- If you plan to order by rank, it is not necessary to specify the clause `ORDER BY` as MySQL does the order forcelly internally. Also,
  the behavior is different from the default as it returns the heaviest at the top (like ORDER BY rank DESC).
- If you come from MyISAM's FTS implementation, recall that the ranking scoring is different.
- Create the FULLTEXT index after the data is loaded [InnoDB bulk load](http://dev.mysql.com/doc/refman/5.7/en/optimizing-innodb-bulk-data-loading.html). When restoring FTS backups, you will probably hit the "ERROR 182 (HY000) at line nn: Invalid InnoDB FTS Doc ID".
- Try to don't use more than one FTS expression in the where clause. Keep in mind that this affects the order in the results and
  it consumes a considerably amount of CPU. MySQL orders by the latest expression in the WHERE clause. [WL#7123](https://dev.mysql.com/worklog/task/?id=7123)
- Also, if avoiding the rank information in the projection (SELECT clause) and using other aggregations like count(*), will use
  the "no ranking" FT_hints. The `limit` hint won't be used if invoked explicitely an `ORDER BY` and th `MATCH` clause in the projection.

```
(test) >  explain  select  * 
                      from bookContentByLine 
                      where match(content) against ("+home" IN BOOLEAN MODE) 
                      ORDER BY FTS_DOC_ID  
                      LIMIT 10\G
  select_type: SIMPLE
        table: bookContentByLine
         type: fulltext
        Extra: Using where; Ft_hints: no_ranking; Using filesort

(test) >  explain  select  * 
                      from bookContentByLine 
                      where match(content) against ("+home" IN BOOLEAN MODE) 
                      LIMIT 10\G
        table: bookContentByLine
         type: fulltext
        Extra: Using where; Ft_hints: no_ranking, limit = 10
        
(test) >  explain  select  count(content) 
                    from bookContentByLine 
                    where match(content) against ("+home" IN BOOLEAN MODE) \G
        table: bookContentByLine
         type: fulltext
        Extra: Using where; Ft_hints: no_ranking

```
- If you plan to use FTS_DOC_ID column with AUTO_INCREMENT option, have in mind that there is a limitation regarding this.You must
  declare a single column PRIMARY KEY constraint or as an UNIQUE index. Also, the data type is stricted as `bigint unsigned`. I.e:

```
CREATE TABLE test ( FTS_DOC_ID bigint unsigned  AUTO_INCREMENT, 
                    mainPk bigint, other text, 
                    PRIMARY KEY(mainPk),
                    UNIQUE(FTS_DOC_ID)
                    );
```



## Stats of the datasets 

Here we prompt some stats regarding the used datasets for the tests and data written here:


```{r, echo=FALSE}

sql <- "SELECT bp.bookid, round(avg(length(bp.content))) as avgLength, round(STD(length(bp.content))) as stdLength, count(*) as numEntries 
            FROM bookContent bp  
            GROUP BY bookid;"
rs <- dbGetQuery(con, sql)
return(rs)

bookContentStats <- rs


sql <- "SELECT bl.bookid, round(avg(length(bl.content))) as avgLength, round(STD(length(bl.content))) as stdLength, count(*) as numEntries 
            FROM  bookContentByLine bl 
            GROUP BY bookid;"
rs <- dbGetQuery(con, sql)
return(rs)

bookContentByLineStats <- rs

```



## Playing with searches

The following form will allow you to search across the stats over the tables of the filtering provided dynamically. 

The aggregations shown on the results are over the results using the selected algorithm. 

You can start trying `+country +(>house <president) -home` in boolean mode. For more information about operator in Innodb's FTS,
you can read [this.](https://dev.mysql.com/doc/refman/5.7/en/fulltext-boolean.html) Using boolean formulas in NATURAL LANGUAGE MODE,
does not have the desired effect, however you'll be able to see how it affects the ranking compared with the boolean search. 

NOTE: distance operator not yet supported.


```{r, echo=FALSE}
        ui <- shinyUI(fluidPage(
                mainPanel(  
                          selectInput("ftsMode", label = "Algorithm:",
                                      choices = c("WITH QUERY EXPANSION", "IN BOOLEAN MODE", "IN NATURAL LANGUAGE MODE"), selected = "WITH QUERY EXPANSION"),
                          textInput("filtering", "FTS Filter:", "default"),
                          submitButton("Stats!"),
                          # uiOutput('tableResults'),
                          uiOutput('table'),
                          uiOutput('tableResults')
                          )
                       ))

        server <- function(input, output, session) {
                
                DataResults = reactive({
                   f<-function(x) {as.character(input$filtering)}
                  sql <- paste("SELECT * FROM bookContentByLine WHERE MATCH(content) AGAINST(\"" ,f(x)," \" ",input$ftsMode,") ", sep = "")
                  
                  rs <- head(dbGetQuery(con, sql), 50)
                  return(rs)
                  
                })
                
                output$tableResults <- renderTable({DataResults()})

                Data = reactive({
                  f<-function(x) {as.character(input$filtering)}
                  
                      sql <- paste("SELECT sourceTable, 
                                      max(scoreBoolean) as maxBoolean,
                                      max(scoreQE) as maxQE,
                                      -- max(scoreNL) as maxNL,
                                      avg(scoreBoolean) as avgBoolean, 
                                      avg(scoreQE) as avgQE,
                                      -- avg(scoreNL) as avgNL,
                                      avg(lengthContent) avgFieldLength,
                                      -- avg(scoreQE) / count(sourceTable) as weight,
                                      count(sourceTable) as countOccurrences
                              FROM
                              (
                              SELECT \"byParagraph\" as sourceTable, 
                                    FTS_DOC_ID, 
                                    match(BC.content) against (\"" ,f(x) ," \" IN BOOLEAN MODE) as scoreBoolean,
                                    match(BC.content) 
                                        against (\""  ,f(x), "\" IN NATURAL LANGUAGE MODE WITH QUERY EXPANSION) scoreQE,
                                    match(BC.content) 
                                        against (\""  ,f(x), "\" IN NATURAL LANGUAGE MODE) scoreNL,
                                     length(content) as lengthContent
                              FROM    bookContent BC
                              WHERE
                                match(BC.content) against (\"" ,f(x)," \" ",input$ftsMode,")
                              UNION
                              SELECT \"byLine\" as sourceTable, 
                                      FTS_DOC_ID, match(BL.content) against (\"",f(x)," \" IN BOOLEAN MODE) as scoreBoolean,
                                     match(BL.content) 
                                      against (\"" ,f(x)," \" IN NATURAL LANGUAGE MODE WITH QUERY EXPANSION) scoreQE,
                                    match(BL.content) 
                                        against (\""  ,f(x), "\" IN NATURAL LANGUAGE MODE) scoreNL,
                                     length(content) as lengthContent
                              FROM
                                      bookContentByLine BL
                              WHERE
                                match(BL.content) against (\"", f(x) ,"\" ",input$ftsMode,")
                              ) unionTable
                              GROUP BY sourceTable
                              ;" , sep = "")

                      rs <- dbGetQuery(con, sql)
                      return(rs)
                      
                })
                        
                output$table <- renderTable({Data()})
                      
        }

shinyApp(ui = ui, server = server)

```


Now that you can see the general stats, we'll see how much noise has been added with the query extension algorithm.
To do that,  we'll gather all the occurrences using the query extension option and extract only the ones that match 
with the occurrence.




### Fine tuning

[Fine tuning](https://dev.mysql.com/doc/refman/5.7/en/fulltext-fine-tuning.html)


### Features introduces

### Maintenance

[innodb_optimize_fulltext_only](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_optimize_fulltext_only)

### Parsers internals

[Writting FTS parser plugins](https://dev.mysql.com/doc/refman/5.7/en/writing-full-text-plugins.html)



