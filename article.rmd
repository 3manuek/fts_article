---
title: "Full text search hack with Shiny/R"
author: "Emanuel Calvo"
date: "December 22, 2015"
output: html_document
runtime: shiny
---

```{r init, message = FALSE, echo=FALSE}
options(width = 9999)
knitr::opts_chunk$set(width=9999)

library(knitr)
library(shiny)
require(RMySQL)
library(ggplot2)


source('~/git/fts_article/load.R')

# Yeah, only for development environements
all_cons <- dbListConnections(MySQL())
for(con in all_cons) dbDisconnect(con)


# You do not want clear passwords, but is a sandbox.
con <- dbConnect(MySQL(), 
                 user="msandbox", password="msandbox", port=14901 
                 ,dbname="test", socket="/tmp/mysql_sandbox14901.sock", 
                 host="127.0.0.1")


```

This R Markdown document is made interactive using Shiny. Unlike the more traditional workflow of creating static reports, you can now create documents that allow your readers to change the assumptions underlying your analysis and see the results immediately.  To learn more, see [Interactive Documents](http://rmarkdown.rstudio.com/authoring_shiny.html).


> You only need to have a MySQL sandbox with the 5.7 version.

## Moto of the article

A couple of days ago one of our customers came up with a question regarding FTS over InnoDB engine. Althuogh the question
is not entirely related with most of the content written here, I came up with the conclusion that FTS sometimes is a misunderstood feature.

The point of this article will be clarify when each algorithm fits in each situation.  

Both official documentation and articles are propagated over internet, however sometimes most of them lacks to answer the
main questions and test cases. In order to follow a reproducible article, I used public available data sources (www.gutenberg.org).

In order to show the effects off the field sizes on the ranking algorithms, you will see two main tables (bookContent and 
bookContentByLine) which contains the books parsed by paragraph and by line respectively. You'll see the noise generated
by the `QUERY EXPANSION` algorithm when phrases are too large, and that's why you see both tables.

The current article has been developed using Shiny/R in order to allow you to see the effects of the algorithms.  

Here is an example of how ranks differ among algorithms and field sizes using the word 'country':

```
set global innodb_ft_aux_table = 'test/bookContentByLine';
 
SELECT  content, group_concat(it.POSITION) as positions, 
        round(MATCH(content) AGAINST ("country" IN NATURAL LANGUAGE MODE WITH QUERY EXPANSION)) as QERank, 
        round(MATCH(content) AGAINST ("country*" IN BOOLEAN MODE)) as BooleanRank, 
        length(content) as len 
      FROM bookContentByLine bl join information_schema.INNODB_FT_INDEX_TABLE it 
          ON (bl.FTS_DOC_ID = it.DOC_ID)  
      WHERE  MATCH(content) AGAINST ("country" IN NATURAL LANGUAGE MODE WITH QUERY EXPANSION) 
          AND lower(it.WORD) like '%country%' group by FTS_DOC_ID ORDER BY 3 DESC LIMIT 10 ;

+---------------------------------------------------------------------------+-----------+--------+-------------+------+
| content                                                                   | positions | QERank | BooleanRank | len  |
+---------------------------------------------------------------------------+-----------+--------+-------------+------+
| "country may be ennobled, and under its auspices may be verified that"    | 1         |     54 |           4 |   70 |
| "country, under a most excellent president, wherein all cities had their" | 1         |     53 |           4 |   73 |
| "Again, the prince who holds a country differing in the above respects"   | 31        |     51 |           4 |   71 |
| "country districts. As Lucca had five gates, he divided his own country"  | 1,63      |     51 |           8 |   72 |
| "inflicting immense damage upon the country. Whereupon the Florentines"   | 36        |     50 |           4 |   71 |
| "The cities of Germany are absolutely free, they own but little country"  | 64        |     49 |           4 |   72 |
| "citizens of Fermo, to whom the slavery of their country was dearer than" | 49        |     48 |           4 |   73 |
| "is useful in two ways. Firstly, he learns to know his country, and"      | 55        |     46 |           4 |   68 |
| "agree that he should retain any lordship over the country. Because the"  | 51        |     45 |           4 |   72 |
| "his own parts of the country, according to the authority he had assumed" | 22        |     43 |           4 |   73 |
+---------------------------------------------------------------------------+-----------+--------+-------------+------+


node1 [localhost] {msandbox} (test) > set global innodb_ft_aux_table = 'test/bookContent';
Query OK, 0 rows affected (0,00 sec)

node1 [localhost] {msandbox} (test) > SELECT FTS_DOC_ID, group_concat(it.POSITION) as positions, round(MATCH(content) AGAINST ("country" IN NATURAL LANGUAGE MODE WITH QUERY EXPANSION)) as QERank, round(MATCH(content) AGAINST ("country*" IN BOOLEAN MODE)) as BooleanRank, length(content) as len FROM bookContent bl join information_schema.INNODB_FT_INDEX_TABLE it ON (bl.FTS_DOC_ID = it.DOC_ID)  WHERE  MATCH(content) AGAINST ("country" IN NATURAL LANGUAGE MODE WITH QUERY EXPANSION) AND lower(it.WORD) like '%country%' group by FTS_DOC_ID ORDER BY QERank DESC LIMIT 10 ;
+------------+------------------+--------+-------------+------+
| FTS_DOC_ID | positions        | QERank | BooleanRank | len  |
+------------+------------------+--------+-------------+------+
|        757 | 6858             |   2804 |           1 | 8101 |
|        735 | 2842             |    925 |           1 | 3133 |
|        157 | 747              |    698 |           1 | 2385 |
|        733 | 265,1342,816,750 |    569 |           2 | 1765 |
|        739 | 1171             |    540 |           1 | 1659 |
|        249 | 197,739          |    435 |           1 | 1368 |
|        279 | 664              |    428 |           1 | 1365 |
|        411 | 468,410          |    396 |           2 | 1170 |
|        155 | 31,495,158,525   |    363 |           5 | 1378 |
|        327 | 60               |    362 |           1 | 1372 |
+------------+------------------+--------+-------------+------+
10 rows in set (4,09 sec)
```

As we can observ on the previous examples, the query extension algorithm has some noisy produced by the double query
generated in order to join  the results.  


```{r, message=FALSE, echo=FALSE}
sql <- "SELECT avg(length(content)) as len from bookContent"
rs <- dbGetQuery(con,sql)
```

Following stats are from the bookContent table (which has an average length of `r rs$len` characters ).

```
node1 [localhost] {msandbox} (test) > select * from information_schema.INNODB_FT_INDEX_TABLE WHERE DOC_ID = 733 AND lower(WORD) like '%country%';
+------------------+--------------+-------------+-----------+--------+----------+
| WORD             | FIRST_DOC_ID | LAST_DOC_ID | DOC_COUNT | DOC_ID | POSITION |
+------------------+--------------+-------------+-----------+--------+----------+
| country          |          149 |         787 |        28 |    733 |      265 |
| country          |          149 |         787 |        28 |    733 |     1342 |
| countrydistricts |          733 |         733 |         1 |    733 |      816 |
| thecountry       |          249 |         733 |         2 |    733 |      750 |
+------------------+--------------+-------------+-----------+--------+----------+
4 rows in set (0,08 sec)

node1 [localhost] {msandbox} (test) > select * from information_schema.INNODB_FT_INDEX_TABLE WHERE DOC_ID = 155 AND lower(WORD) like '%country%';
+---------+--------------+-------------+-----------+--------+----------+
| WORD    | FIRST_DOC_ID | LAST_DOC_ID | DOC_COUNT | DOC_ID | POSITION |
+---------+--------------+-------------+-----------+--------+----------+
| country |          149 |         787 |        28 |    155 |       31 |
| country |          149 |         787 |        28 |    155 |      495 |
| country |          149 |         787 |        28 |    155 |      158 |
| country |          149 |         787 |        28 |    155 |      525 |
+---------+--------------+-------------+-----------+--------+----------+
4 rows in set (0,09 sec)

```

> In the example shown before the is no intention to compare ranks score as they are based in different algorithms. 
> The idea there is to show that QUERY EXPANSION can have non desire results in some cases due to its mechanism.


## Playing with searches


The following form will allow you to search across the stats over the tables
of the filtering provided dynamically. 

Keep in mind that the numbers are not meaningful as we can't compare rankings
between `query extension` and `boolean`. 

```{r, echo=FALSE}
        ui <- shinyUI(fluidPage(
                mainPanel(textInput("filtering", "FTS Filter:", "default"),
                          submitButton("Stats!"),
                          uiOutput('table')
                          )
        ))

        server <- function(input, output, session) {
                 
                Data = reactive({
                  f<-function(x) {as.character(input$filtering)}
                  
                      sql <- paste("SELECT sourceTable, 
                                      sum(scoreBoolean) as sumBoolean, 
                                      sum(scoreQE) as sumQE,
                                      max(scoreBoolean) as maxBoolean,
                                      max(scoreQE) as maxBoolean,
                                      avg(scoreBoolean) as avgBoolean, 
                                      avg(scoreQE) as avgQE,
                                      avg(lengthContent) avgLength,
                                      avg(scoreQE) / count(sourceTable) as weight,
                                      count(sourceTable) as countOccurrences
                              FROM
                              (
                              SELECT \"byParagraph\" as sourceTable, 
                                    FTS_DOC_ID, match(BC.content) against (\"" ,f(x) ," \" IN BOOLEAN MODE) as scoreBoolean,
                                     match(BC.content) 
                                        against (\""  ,f(x), "\" IN NATURAL LANGUAGE MODE WITH QUERY EXPANSION) scoreQE,
                                     length(content) as lengthContent
                              FROM    bookContent BC
                              WHERE
                                match(BC.content) against (\"" ,f(x)," \" IN NATURAL LANGUAGE MODE WITH QUERY EXPANSION)
                              UNION
                              SELECT \"byLine\" as sourceTable, 
                                      FTS_DOC_ID, match(BL.content) against (\"",f(x)," \" IN BOOLEAN MODE) as scoreBoolean,
                                     match(BL.content) 
                                      against (\"" ,f(x)," \" IN NATURAL LANGUAGE MODE WITH QUERY EXPANSION) scoreQE,
                                     length(content) as lengthContent
                              FROM
                                      bookContentByLine BL
                              WHERE
                                match(BL.content) against (\"", f(x) ,"\" IN NATURAL LANGUAGE MODE WITH QUERY EXPANSION)
                              ) unionTable
                              GROUP BY sourceTable
                              ;" , sep = "")

                      rs <- dbGetQuery(con, sql)
                      return(rs)
                      
                })
                        
                        output$table <- renderTable({Data()})
                                
        }

shinyApp(ui = ui, server = server)

```

Template

```{r}
inputPanel(
  selectInput("n_breaks", label = "Number of bins:",
              choices = c(10, 20, 35, 50), selected = 20),
  
  sliderInput("bw_adjust", label = "Bandwidth adjustment:",
              min = 0.2, max = 2, value = 1, step = 0.2)
)

renderPlot({
  hist(faithful$eruptions, probability = TRUE, breaks = as.numeric(input$n_breaks),
       xlab = "Duration (minutes)", main = "Geyser eruption duration")
  
  dens <- density(faithful$eruptions, adjust = input$bw_adjust)
  lines(dens, col = "blue")
})
```

## Embedded Application

It's also possible to embed an entire Shiny application within an R Markdown document using the `shinyAppDir` function. This example embeds a Shiny application located in another directory:

```{r, echo=FALSE}
shinyAppDir(
  system.file("examples/06_tabsets", package="shiny"),
  options=list(
    width="100%", height=550
  )
)
```

Note the use of the `height` parameter to determine how much vertical space the embedded application should occupy.

You can also use the `shinyApp` function to define an application inline rather then in an external directory.

In all of R code chunks above the `echo = FALSE` attribute is used. This is to prevent the R code within the chunk from rendering in the document alongside the Shiny components.



