---
title: "InnoDB Full text Search hacking with Shiny/R"
author: "Emanuel Calvo"
date: "December 22, 2015"
output: html_document
runtime: shiny
---

```{r init, message = FALSE, echo=FALSE}
#options(width = 9999)
#knitr::opts_chunk$set(width=9999)

library(knitr)
library(shiny)
require(RMySQL)
library(ggplot2)

#Comment if you want to avoid reload all the data
#source('~/fts_article/load.R')

# Yeah, only for development environements
all_cons <- dbListConnections(MySQL())
for(con in all_cons) dbDisconnect(con)


# You do not want clear passwords, but is a sandbox.
con <- dbConnect(MySQL(), 
                 user="msandbox", password="msandbox", port=14901 
                 ,dbname="test", socket="/tmp/mysql_sandbox14901.sock", 
                 host="127.0.0.1")


```

This R Markdown document is made interactive using Shiny. Unlike the more traditional workflow of creating static reports, you can now create documents that allow your readers to change the assumptions underlying your analysis and see the results immediately.  To learn more, see [Interactive Documents](http://rmarkdown.rstudio.com/authoring_shiny.html).


> You only need to have a MySQL sandbox with the 5.7 version.

## Moto of the article

A couple of days ago one of our customers came up with a question regarding FTS over InnoDB engine. Althuogh the question
is not entirely related with most of the content written here, I came up with the conclusion that FTS sometimes is a misunderstood feature.

The point of this article will be clarify when each algorithm fits in each situation.  

Both official documentation and articles are propagated over internet, however sometimes most of them lacks to answer the
main questions and test cases. In order to follow a reproducible article, I used public available data sources (www.gutenberg.org).

In order to show the effects off the field sizes on the ranking algorithms, you will see two main tables (bookContent and 
bookContentByLine) which contains the books parsed by paragraph and by line respectively. You'll see the noise generated
by the `QUERY EXPANSION` algorithm when phrases are too large, and that's why you see both tables.

The current article has been developed using Shiny/R in order to allow you to see the effects of the algorithms.  

Here is an example of how ranks differ among algorithms and field sizes using the word 'country':

```
set global innodb_ft_aux_table = 'test/bookContentByLine';
 
SELECT  content, group_concat(it.POSITION) as positions, 
        round(MATCH(content) AGAINST ("country" IN NATURAL LANGUAGE MODE WITH QUERY EXPANSION)) as QERank, 
        round(MATCH(content) AGAINST ("country*" IN BOOLEAN MODE)) as BooleanRank, 
        length(content) as len 
      FROM bookContentByLine bl join information_schema.INNODB_FT_INDEX_TABLE it 
          ON (bl.FTS_DOC_ID = it.DOC_ID)  
      WHERE  MATCH(content) AGAINST ("country" IN NATURAL LANGUAGE MODE WITH QUERY EXPANSION) 
          AND lower(it.WORD) like '%country%' group by FTS_DOC_ID ORDER BY 3 DESC LIMIT 10 ;

+---------------------------------------------------------------------------+-----------+--------+-------------+------+
| content                                                                   | positions | QERank | BooleanRank | len  |
+---------------------------------------------------------------------------+-----------+--------+-------------+------+
| "country may be ennobled, and under its auspices may be verified that"    | 1         |     54 |           4 |   70 |
| "country, under a most excellent president, wherein all cities had their" | 1         |     53 |           4 |   73 |
| "Again, the prince who holds a country differing in the above respects"   | 31        |     51 |           4 |   71 |
| "country districts. As Lucca had five gates, he divided his own country"  | 1,63      |     51 |           8 |   72 |
| "inflicting immense damage upon the country. Whereupon the Florentines"   | 36        |     50 |           4 |   71 |
| "The cities of Germany are absolutely free, they own but little country"  | 64        |     49 |           4 |   72 |
| "citizens of Fermo, to whom the slavery of their country was dearer than" | 49        |     48 |           4 |   73 |
| "is useful in two ways. Firstly, he learns to know his country, and"      | 55        |     46 |           4 |   68 |
| "agree that he should retain any lordship over the country. Because the"  | 51        |     45 |           4 |   72 |
| "his own parts of the country, according to the authority he had assumed" | 22        |     43 |           4 |   73 |
+---------------------------------------------------------------------------+-----------+--------+-------------+------+


```

As we can observ on the previous examples, the query extension algorithm has some noisy produced by the double query
generated in order to join  the results. Also, it won't matter if you have the exact match twice, as the algorithm does not
focus on the exact matches, instead it will relate the occurrences on the first search (where the match happens) and the
sencond (where the algorithm searches for the words that appear in the same phrase than the exact match). That means 
that it is possible to have a high rank without have any exact matching occurrence.

The interesting case is the following row, which has 2 exact occurrences and it is not the highest rank using query
extension. Remember, this is expected.

```
| "country districts. As Lucca had five gates, he divided his own country"  | 1,63      |     51 |           8 |   72 |
```

Even worst when using large sentences. In the example bellow you will see the same query, against the table 
storing by paragraph. The boolean rank shows some of the entries way above others, however the query extension
locates at the top records that not necessarily has a lot of exact matches.

```

node1 [localhost] {msandbox} (test) > set global innodb_ft_aux_table = 'test/bookContent';
Query OK, 0 rows affected (0,00 sec)

node1 [localhost] {msandbox} (test) > SELECT FTS_DOC_ID, group_concat(it.POSITION) as positions, round(MATCH(content) AGAINST ("country" IN NATURAL LANGUAGE MODE WITH QUERY EXPANSION)) as QERank, round(MATCH(content) AGAINST ("country*" IN BOOLEAN MODE)) as BooleanRank, length(content) as len FROM bookContent bl join information_schema.INNODB_FT_INDEX_TABLE it ON (bl.FTS_DOC_ID = it.DOC_ID)  WHERE  MATCH(content) AGAINST ("country" IN NATURAL LANGUAGE MODE WITH QUERY EXPANSION) AND lower(it.WORD) like '%country%' group by FTS_DOC_ID ORDER BY QERank DESC LIMIT 10 ;
+------------+------------------+--------+-------------+------+
| FTS_DOC_ID | positions        | QERank | BooleanRank | len  |
+------------+------------------+--------+-------------+------+
|        757 | 6858             |   2804 |           1 | 8101 |
|        735 | 2842             |    925 |           1 | 3133 |
|        157 | 747              |    698 |           1 | 2385 |
|        733 | 265,1342,816,750 |    569 |           2 | 1765 |
|        739 | 1171             |    540 |           1 | 1659 |
|        249 | 197,739          |    435 |           1 | 1368 |
|        279 | 664              |    428 |           1 | 1365 |
|        411 | 468,410          |    396 |           2 | 1170 |
|        155 | 31,495,158,525   |    363 |           5 | 1378 |
|        327 | 60               |    362 |           1 | 1372 |
+------------+------------------+--------+-------------+------+
10 rows in set (4,09 sec)
```


This kind of searches is useful if you want to find entries with words that appear frequently within your search.


```{r, message=FALSE, echo=FALSE}
sql <- "SELECT avg(length(content)) as len from bookContent"
rs <- dbGetQuery(con,sql)
```

Following stats are from the bookContent table (which has an average length of `r rs$len` characters ).

```
(test) > select * 
          from information_schema.INNODB_FT_INDEX_TABLE 
          WHERE DOC_ID = 733 AND lower(WORD) like '%country%';
+------------------+--------------+-------------+-----------+--------+----------+
| WORD             | FIRST_DOC_ID | LAST_DOC_ID | DOC_COUNT | DOC_ID | POSITION |
+------------------+--------------+-------------+-----------+--------+----------+
| country          |          149 |         787 |        28 |    733 |      265 |
| country          |          149 |         787 |        28 |    733 |     1342 |
| countrydistricts |          733 |         733 |         1 |    733 |      816 |
| thecountry       |          249 |         733 |         2 |    733 |      750 |
+------------------+--------------+-------------+-----------+--------+----------+
4 rows in set (0,08 sec)

(test) > select * 
          from information_schema.INNODB_FT_INDEX_TABLE 
          WHERE DOC_ID = 155 AND lower(WORD) like '%country%';
+---------+--------------+-------------+-----------+--------+----------+
| WORD    | FIRST_DOC_ID | LAST_DOC_ID | DOC_COUNT | DOC_ID | POSITION |
+---------+--------------+-------------+-----------+--------+----------+
| country |          149 |         787 |        28 |    155 |       31 |
| country |          149 |         787 |        28 |    155 |      495 |
| country |          149 |         787 |        28 |    155 |      158 |
| country |          149 |         787 |        28 |    155 |      525 |
+---------+--------------+-------------+-----------+--------+----------+
4 rows in set (0,09 sec)

```

> In the example shown before the is no intention to compare ranks score as they are based in different algorithms. 
> The idea there is to show that QUERY EXPANSION can have non desire results in some cases due to its mechanism.


## Playing with searches

The following form will allow you to search across the stats over the tables of the filtering provided dynamically. 

The aggregations shown on the results are over the results using the selected algorithm. The aggregations over
the query expansion ranks are only against the results, not all the rows.


```{r, echo=FALSE}
        ui <- shinyUI(fluidPage(
                mainPanel(  
                          selectInput("ftsMode", label = "Algorithm:",
                                      choices = c("WITH QUERY EXPANSION", "IN BOOLEAN MODE", "IN NATURAL LANGUAGE MODE"), selected = "WITH QUERY EXTENSION"),
                          textInput("filtering", "FTS Filter:", "default"),
                          submitButton("Stats!"),
                          uiOutput('table')
                          )
                       ))

        server <- function(input, output, session) {
                 
                Data = reactive({
                  f<-function(x) {as.character(input$filtering)}
                  
                      sql <- paste("SELECT sourceTable, 
                                      max(scoreBoolean) as maxBoolean,
                                      max(scoreQE) as maxQE,
                                      max(scoreNL) as maxNL,
                                      avg(scoreBoolean) as avgBoolean, 
                                      avg(scoreQE) as avgQE,
                                      avg(scoreNL) as avgNL,
                                      avg(lengthContent) avgFieldLength,
                                      -- avg(scoreQE) / count(sourceTable) as weight,
                                      count(sourceTable) as countOccurrences
                              FROM
                              (
                              SELECT \"byParagraph\" as sourceTable, 
                                    FTS_DOC_ID, 
                                    match(BC.content) against (\"" ,f(x) ," \" IN BOOLEAN MODE) as scoreBoolean,
                                    match(BC.content) 
                                        against (\""  ,f(x), "\" IN NATURAL LANGUAGE MODE WITH QUERY EXPANSION) scoreQE,
                                    match(BC.content) 
                                        against (\""  ,f(x), "\" IN NATURAL LANGUAGE MODE) scoreNL,
                                     length(content) as lengthContent
                              FROM    bookContent BC
                              WHERE
                                match(BC.content) against (\"" ,f(x)," \" ",input$ftsMode,")
                              UNION
                              SELECT \"byLine\" as sourceTable, 
                                      FTS_DOC_ID, match(BL.content) against (\"",f(x)," \" IN BOOLEAN MODE) as scoreBoolean,
                                     match(BL.content) 
                                      against (\"" ,f(x)," \" IN NATURAL LANGUAGE MODE WITH QUERY EXPANSION) scoreQE,
                                    match(BL.content) 
                                        against (\""  ,f(x), "\" IN NATURAL LANGUAGE MODE) scoreNL,
                                     length(content) as lengthContent
                              FROM
                                      bookContentByLine BL
                              WHERE
                                match(BL.content) against (\"", f(x) ,"\" ",input$ftsMode,")
                              ) unionTable
                              GROUP BY sourceTable
                              ;" , sep = "")

                      rs <- dbGetQuery(con, sql)
                      return(rs)
                      
                })
                        
                        output$table <- renderTable({Data()})
                                
        }

shinyApp(ui = ui, server = server)

```


Now that you can see the general stats, we'll see how much noise has been added with the query extension algorithm.
To do that,  we'll gather all the occurrences using the query extension option and extract only the ones that match 
with the occurrence.


Template

```{r}
inputPanel(
  selectInput("n_breaks", label = "Number of bins:",
              choices = c(10, 20, 35, 50), selected = 20),
  
  sliderInput("bw_adjust", label = "Bandwidth adjustment:",
              min = 0.2, max = 2, value = 1, step = 0.2)
)

renderPlot({
  hist(faithful$eruptions, probability = TRUE, breaks = as.numeric(input$n_breaks),
       xlab = "Duration (minutes)", main = "Geyser eruption duration")
  
  dens <- density(faithful$eruptions, adjust = input$bw_adjust)
  lines(dens, col = "blue")
})
```

## Embedded Application

It's also possible to embed an entire Shiny application within an R Markdown document using the `shinyAppDir` function. This example embeds a Shiny application located in another directory:

```{r, echo=FALSE}
shinyAppDir(
  system.file("examples/06_tabsets", package="shiny"),
  options=list(
    width="100%", height=550
  )
)
```

Note the use of the `height` parameter to determine how much vertical space the embedded application should occupy.

You can also use the `shinyApp` function to define an application inline rather then in an external directory.

In all of R code chunks above the `echo = FALSE` attribute is used. This is to prevent the R code within the chunk from rendering in the document alongside the Shiny components.

### Fine tuning

[Fine tuning](https://dev.mysql.com/doc/refman/5.7/en/fulltext-fine-tuning.html)


### Maintenance

[innodb_optimize_fulltext_only](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_optimize_fulltext_only)

### Parsers internals

[Writting FTS parser plugins](https://dev.mysql.com/doc/refman/5.7/en/writing-full-text-plugins.html)



